use super::lang::OutputLang;
use super::phash::PHash;
use std::collections::HashMap;
use std::fs::File;
use std::io::BufWriter;
use std::io::Write;
use std::path::PathBuf;
use strfmt::strfmt;

pub fn gen_code(
    output_path: PathBuf,
    phash: &PHash,
    name: &str,
    namespace: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let ext = output_path
        .extension()
        .and_then(|e| e.to_str())
        .expect("Cannot deduce the output language from the output file extension");

    let output_lang: OutputLang = ext.into();

    println!(
        "Generating {:?} code to file: {}",
        output_lang,
        output_path.display()
    );

    let output_file = File::create(&output_path).expect("Cannot create output file");
    let mut output_buffer = BufWriter::new(output_file);

    let cm_st = output_lang.get_comment_start();
    let cm_end = output_lang.get_comment_end();

    write!(
        output_buffer,
        "{cm_st} This file has been auto-generated by pho {cm_end}\n"
    )?;
    write!(
        output_buffer,
        "{cm_st} Check out https://github.com/romainaugier/pho for more information {cm_end}\n"
    )?;
    write!(output_buffer, "\n")?;

    let mut vars = HashMap::new();

    let first_item = phash
        .first_item()
        .unwrap_or_else(|| panic!("Cannot find any item"));

    output_lang
        .get_imports_from_type(first_item.item_type())
        .and_then(|imports| write!(output_buffer, "{}\n", imports).ok());

    // First-order hash function

    let fo_hash_name = phash.fo_hash().name();
    let fo_hash_data = output_lang
        .get_fo_hash_data(fo_hash_name)
        .expect("Cannot get the fo hash function data");
    let fo_function_name = format!("{namespace}_{fo_hash_name}").to_string();
    vars.insert("name".to_string(), fo_function_name.clone());

    write!(
        output_buffer,
        "{}",
        strfmt(&fo_hash_data.body, &vars).unwrap()
    )?;
    write!(output_buffer, "\n")?;

    // Second-order hash function

    let so_hash_name = phash.so_hash().name();
    let so_hash_data = output_lang
        .get_so_hash_data(so_hash_name)
        .expect("Cannot get the so hash function data");
    let so_function_name = format!("{namespace}_{so_hash_name}").to_string();
    vars.insert("name".to_string(), so_function_name.clone());

    write!(
        output_buffer,
        "{}",
        strfmt(&so_hash_data.body, &vars).unwrap()
    )?;
    write!(output_buffer, "\n")?;

    // Seeds

    let so_seeds_name = format!("{namespace}_{name}_seeds");
    vars.insert("name".to_string(), so_seeds_name.clone());
    vars.insert(
        "type".to_string(),
        output_lang.map_type::<u32>(&0).to_string(),
    );
    vars.insert("size".to_string(), format!("{}", phash.buckets().len()));

    write!(
        output_buffer,
        "{} = {}",
        strfmt(&output_lang.get_array_decl(), &vars).unwrap(),
        output_lang.get_array_start()
    )?;
    write!(output_buffer, "\n")?;

    for bucket in phash.buckets().iter() {
        write!(
            output_buffer,
            "    {}{}",
            bucket.so_hash().seed(),
            output_lang.get_array_sep()
        )?;
        write!(output_buffer, "\n")?;
    }

    write!(
        output_buffer,
        "{}{}",
        output_lang.get_array_end(),
        output_lang.get_line_end()
    )?;
    write!(output_buffer, "\n")?;
    write!(output_buffer, "\n")?;

    // Values

    let values_name = format!("{namespace}_{name}_values");
    vars.insert("name".to_string(), values_name.clone());
    vars.insert(
        "type".to_string(),
        output_lang.get_type(first_item.item_type()).to_string(),
    );
    vars.insert("size".to_string(), format!("{}", phash.m()));

    write!(
        output_buffer,
        "{} = {}",
        strfmt(&output_lang.get_array_decl(), &vars).unwrap(),
        output_lang.get_array_start()
    )?;
    write!(output_buffer, "\n")?;

    for item in phash.items().iter() {
        write!(
            output_buffer,
            "    {}{}",
            item.item_type().to_string(),
            output_lang.get_array_sep()
        )?;
        write!(output_buffer, "\n")?;
    }

    write!(
        output_buffer,
        "{}{}",
        output_lang.get_array_end(),
        output_lang.get_line_end()
    )?;
    write!(output_buffer, "\n")?;
    write!(output_buffer, "\n")?;

    // Get function

    let get_function_name = format!("{namespace}_{name}_get");
    vars.insert("name".to_string(), get_function_name);
    vars.insert(
        "type".to_string(),
        output_lang.get_type(first_item.item_type()).to_string(),
    );
    vars.insert("fo_function_name".to_string(), fo_function_name);
    vars.insert("so_function_name".to_string(), so_function_name);
    vars.insert("so_seeds_name".to_string(), so_seeds_name);
    vars.insert("num_seeds".to_string(), phash.buckets().len().to_string());
    vars.insert("values_name".to_string(), values_name);
    vars.insert("m".to_string(), phash.m().to_string());
    vars.insert(
        "key_address".to_string(),
        output_lang
            .get_key_address(first_item.item_type())
            .to_string(),
    );
    vars.insert(
        "key_size".to_string(),
        output_lang.get_key_size(first_item.item_type(), "key"),
    );
    vars.insert(
        "key_conversion_start".to_string(),
        output_lang
            .get_key_conversion_start(first_item.item_type())
            .to_string(),
    );
    vars.insert(
        "key_conversion_end".to_string(),
        output_lang
            .get_key_conversion_end(first_item.item_type())
            .to_string(),
    );

    write!(
        output_buffer,
        "{}",
        strfmt(
            &output_lang
                .get_get_data()
                .expect("Cannot get the get function data")
                .body,
            &vars
        )
        .unwrap()
    )?;

    println!("Wrote to \"{}\" successfully", output_path.display());

    return Ok(());
}
